/*
This file was generated by template ../NDArray.Elementwise.tt
In case you want to do some changes do the following 

1 ) adapt the tt file
2 ) execute powershell file "GenerateCode.ps1" on root level

*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using NumSharp.Backends.Unmanaged;
using NumSharp.Utilities;

namespace NumSharp.Backends
{
    public partial class DefaultEngine
    {
            [MethodImpl((MethodImplOptions)768)]
        [SuppressMessage("ReSharper", "JoinDeclarationAndInitializer")]
        public override unsafe NDArray Add(NDArray lhs, NDArray rhs)
        {
            //if return type is scalar
            if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                return NDArray.Scalar((double)(*((double*)lhs.Address) + *((double*)rhs.Address)));

            (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
            var lhs_address = (double*)lhs.Address;
            var rhs_address = (double*)rhs.Address;

            var ret = new NDArray(np._FindCommonType(lhs, rhs), new Shape(BroadcastedLeftShape.dimensions));
            var ret_address = (double*)ret.Address;
            Shape retShape = ret.Shape;

            var incr = new NDIndexArrayIncrementor(BroadcastedLeftShape.dimensions); //doesn't matter which side it is.
            int[] current = incr.Index;
            do
            {
                *(ret_address + retShape.GetOffset(current)) = (double)(*(lhs_address + BroadcastedLeftShape.GetOffset(current)) + *(rhs_address + BroadcastedRightShape.GetOffset(current)));
            } while (incr.Next() != null);

            return ret;
        }


        [MethodImpl((MethodImplOptions)768)]
        [SuppressMessage("ReSharper", "JoinDeclarationAndInitializer")]
        public override unsafe NDArray Add(NDArray lhs, NDArray rhs)
        {
            var x = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
            lhs = new NDArray(lhs.Storage.Alias(x.LeftShape));
            rhs = new NDArray(rhs.Storage.Alias(x.RightShape));
            //if return type is scalar
            if (x.LeftShape.IsScalar)
            {
                return NDArray.Scalar(lhs.GetDouble(0) + rhs.GetDouble(0));
            }

            var ret = new NDArray(np._FindCommonType(lhs,rhs), new Shape(x.LeftShape.dimensions));
            Shape retShape = ret.Shape;

            var incr = new NDIndexArrayIncrementor(ref x.LeftShape);
            var current = incr.Index;
            do
            {
                var l = lhs.GetDouble(current);
                var r = rhs.GetDouble(current);
                var v = l + r;
                ret.SetAtIndex(v, retShape.GetOffset(current));
            } while (incr.Next() != null);

            return ret;

//            NPTypeCode outType;
//            var retShape = ResolveReturnShape(lhs.Shape, rhs.Shape);
//            int size = lhs.size > rhs.size ? lhs.size : rhs.size;
//            NDArray results = null; //todo remove =null


//            var isLeftScalar = lhs.Shape.IsScalar;
//            var isRightScalar = rhs.Shape.IsScalar;
//            if (isLeftScalar && isRightScalar)
//            {
//                outType = np._FindCommonType_Scalar(lhs.GetTypeCode, rhs.GetTypeCode);
//                //Both are a scalar

//                #region Math

//                switch (lhs.GetTypeCode)
//                {
//#if _REGEN
//                %foreach supported_numericals,supported_numericals_lowercase%
//                    case NPTypeCode.#1: return NDArray.Scalar((#2) (ValueType) (*(#2*) lhs.Address + *(#2*) rhs.Address), outType);
//                %
//                    default:
//                        throw new NotSupportedException();
//#else
//                    case NPTypeCode.Byte: return NDArray.Scalar((byte)(ValueType)(*(byte*)lhs.Address + *(byte*)rhs.Address), outType);
//                    case NPTypeCode.Int16: return NDArray.Scalar((short)(ValueType)(*(short*)lhs.Address + *(short*)rhs.Address), outType);
//                    case NPTypeCode.UInt16: return NDArray.Scalar((ushort)(ValueType)(*(ushort*)lhs.Address + *(ushort*)rhs.Address), outType);
//                    case NPTypeCode.Int32: return NDArray.Scalar((int)(ValueType)(*(int*)lhs.Address + *(int*)rhs.Address), outType);
//                    case NPTypeCode.UInt32: return NDArray.Scalar((uint)(ValueType)(*(uint*)lhs.Address + *(uint*)rhs.Address), outType);
//                    case NPTypeCode.Int64: return NDArray.Scalar((long)(ValueType)(*(long*)lhs.Address + *(long*)rhs.Address), outType);
//                    case NPTypeCode.UInt64: return NDArray.Scalar((ulong)(ValueType)(*(ulong*)lhs.Address + *(ulong*)rhs.Address), outType);
//                    case NPTypeCode.Char: return NDArray.Scalar((char)(ValueType)(*(char*)lhs.Address + *(char*)rhs.Address), outType);
//                    case NPTypeCode.Double: return NDArray.Scalar((double)(ValueType)(*(double*)lhs.Address + *(double*)rhs.Address), outType);
//                    case NPTypeCode.Single: return NDArray.Scalar((float)(ValueType)(*(float*)lhs.Address + *(float*)rhs.Address), outType);
//                    case NPTypeCode.Decimal: return NDArray.Scalar((decimal)(ValueType)(*(decimal*)lhs.Address + *(decimal*)rhs.Address), outType);
//                    default:
//                        throw new NotSupportedException();
//#endif

//                    #endregion
//                }
//            }

//            if (!isLeftScalar && !isRightScalar)
//            {
//                var leftShape = lhs.Shape;
//                var rightShape = rhs.Shape;
//                //case 1
//                //when shapes are equals

//                //case 2
//                //(1, n) (m, 1)

//                //case 3
//                //ndim > 2
//                //we create an iterator for the dim minus 
//                halftwin();
//                return results;

//                void halftwin()
//                {
//                    bool equals = leftShape == rightShape;
//                    if (equals)
//                    {
//                        outType = np._FindCommonArrayType(lhs.GetTypeCode, rhs.GetTypeCode);
//                        //Debug.Assert(lhs.Shape == rhs.Shape);

//                        results = new NDArray(new UnmanagedStorage(ArraySlice.Allocate(outType, retShape.size, true), retShape));

//                        //case 1
//                        //linear add

//                        //todo switch outType to set the variable
//                        var retStart = (int*)results.Address;
//                        var leftStart = (int*)lhs.Address;
//                        var rightStart = (int*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(retStart + i) = (int)(*(leftStart + i) + (int)(*(rightStart + i))); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(retStart + i) = (int)(*(leftStart + i) + rightStart);
//                            }
//                        }
//                    }
//                    else
//                    {
//                        if (leftShape.NDim >= 2 && rightShape.NDim >= 2)
//                        {
//                            var _lenleft = leftShape.Dimensions.Length;
//                            var _lenright = rightShape.Dimensions.Length;
//                            var l_row = leftShape[_lenleft - 2];
//                            var l_col = leftShape[_lenleft - 1];
//                            var r_row = rightShape[_lenright - 2];
//                            var r_col = rightShape[_lenright - 1];

//                            //are the last two dimensions are equal:
//                            if (l_row == r_row && l_col == r_col)
//                            {
//                                //case 3 when dimensions before last 2 do not match, like:
//                                //(3,1,2,2) @ (5,4,2,2)
//                                //@Left: ------------
//                                //shape: (3, 3)  size: 9
//                                //[[0 1 2]
//                                // [3 4 5]
//                                // [6 7 8]]
//                                //
//                                //@Right: -----------
//                                //shape: (1, 3)  size: 3
//                                //[[0 1 2]]
//                                //
//                                //@Result: ----------
//                                //shape: (3, 3)  size: 9
//                                //[[0  2  4]
//                                // [3  5  7]
//                                // [6  8 10]]
//                                //------------------

//                                //@Left: ------------
//                                //shape: (3, 3)  size: 9
//                                //[[0 1 2]
//                                //[3 4 5]
//                                //[6 7 8]]
//                                //
//                                //@Right: -----------
//                                //shape: (3, 1)  size: 3
//                                //[[0]
//                                // [1]
//                                // [2]]
//                                //
//                                //@Result: ----------
//                                //shape: (3, 3)  size: 9
//                                //[[0  1  2]
//                                // [4  5  6]
//                                // [8  9 10]]
//                                //------------------

//                                //@Left: ------------
//                                //shape: (3, 3)  size: 9
//                                //[[0 1 2]
//                                // [3 4 5]
//                                // [6 7 8]]
//                                //
//                                //@Right: -----------
//                                //shape: (3, 3)  size: 9
//                                //[[0 1 2]
//                                // [3 4 5]
//                                // [6 7 8]]
//                                //
//                                //@Result: ----------
//                                //shape: (3, 3)  size: 9
//                                //[[ 0  2  4]
//                                // [ 6  8 10]
//                                // [12 14 16]]
//                                //------------------

//                                outType = np._FindCommonArrayType(lhs.GetTypeCode, rhs.GetTypeCode);
//                                //Debug.Assert(lhs.Shape == rhs.Shape);

//                                results = new NDArray(new UnmanagedStorage(ArraySlice.Allocate(outType, retShape.size, true), retShape));

//                                var retIter = new NDIndexArrayIncrementor(ref retShape);
//                                var leftIter = new NDIndexArrayIncrementor(ref leftShape);
//                                var rightIter = new NDIndexArrayIncrementor(ref rightShape);

//                                var len = retShape.size;
//                                int di = 0;
//                                int[] l = leftIter.Index, r = rightIter.Index, ret = retIter.Index;

//                                _repeat:
//                                results.SetAtIndex(lhs.GetAtIndex<int>(di) + rhs.GetAtIndex<int>(di), di);

//                                if (++di >= len)
//                                    goto _break;
//                                leftIter.Next();
//                                rightIter.Next();
//                                retIter.Next();
//                                goto _repeat;
//                                _break: ;
//                                Console.WriteLine(results.ToString(false));
//                                //var MoveNext = () => *((T*)localBlock.Address + iterator.Next());
//                                //var Reset = () => iterator.Reset();
//                            }
//                            //are they half twins (1-sized dimension is once in every shape) 
//                            //(1, n) @ (m, 1)
//                            else if (leftShape[_lenleft - 1] == 1 && rightShape[_lenright - 2] == 1 || leftShape[_lenleft - 2] == 1 && rightShape[_lenright - 1] == 1)
//                            {
//                                //case 2
//                            }
//                            else
//                            { }
//                        }
//                    }
//                }


//                //shaves the last two dimensions out of the array.
//                int[] shaveLastTwo(int[] input)
//                {
//                    Array.Resize(ref input, Math.Max(0, input.Length - 2));
//                    return input;
//                }


//                outType = np._FindCommonArrayType(lhs.GetTypeCode, rhs.GetTypeCode);
//                //Debug.Assert(lhs.Shape == rhs.Shape);
//                results = new NDArray(new UnmanagedStorage(ArraySlice.Allocate(outType, retShape.size, true), retShape));

//                {
//                    //None are a scalar
//                    var rows = lhs.Shape[0];
//                    var columns = rhs.Shape[1];
//                    var resultStart = (int*)results.Address;
//                    var leftStart = (int*)lhs.Address;
//                    var rightStart = (int*)rhs.Address;

//                    for (int i = 0; i < rows; i++)
//                    {
//                        for (int j = 0; j < columns; j++)
//                        {
//                            *(resultStart + i) = (int)(*(leftStart + lhs.Shape.GetOffset(i, j) % lhs.size) + *(rightStart + rhs.Shape.GetOffset(j, i) % rhs.size));
//                        }
//                    }
//                }

//                ;

//                #region Math

//                switch (lhs.GetTypeCode)
//                {
//#if _REGEN
//	            %foreach supported_numericals,supported_numericals_lowercase%
//                    case NPTypeCode.#1: 
//                    {
//                        var resultStart = (#2*) results.Address;
//                        var leftStart = (#2*) lhs.Address;
//                        var rightStart = (#2*) rhs.Address;
//                        if (lhsCount > ParallelLimit) {
//                            Parallel.For(0, lhsCount, i => { *(resultStart + i) = (#2)(*(leftStart + i) + *(rightStart + i)); });
//                        } else {
//                            for (int i = 0; i < lhsCount; i++) {
//                                *(resultStart + i) = (#2)(*(leftStart + i) + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }
//                %

//                    default:
//                        throw new NotSupportedException();
//#else

//#endif
//                }

//                #endregion

//                return results;
//            }

//            if (isRightScalar)
//            {
//                //Right is a scalar
//                results = new NDArray(np._FindCommonArrayScalarType(lhs.GetTypeCode, rhs.GetTypeCode));
//                results.Storage.Allocate(retShape);

//                switch (lhs.GetTypeCode)
//                {
//#if _REGEN
//	                %foreach supported_numericals,supported_numericals_lowercase%
//                        case NPTypeCode.#1: {
//                            var resultStart = (#2*) results.Address;
//                            var leftStart = (#2*) lhs.Address;
//                            var rightScalar = *(#2*)rhs.Address;
//                            if (lhsCount > ParallelLimit) {
//                                Parallel.For(0, lhsCount, i => { *(resultStart + i) = (#2) (*(leftStart + i) + rightScalar); });
//                            } else {
//                                for (int i = 0; i < lhsCount; i++) {
//                                    *(resultStart + i) = (#2) (*(leftStart + i) + rightScalar);
//                                }
//                            }

//                            break;
//                        }
//                    %

//                        default:
//                            throw new NotSupportedException();
//#else
//                    case NPTypeCode.Byte:
//                    {
//                        var resultStart = (byte*)results.Address;
//                        var leftStart = (byte*)lhs.Address;
//                        var rightScalar = *(byte*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (byte)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (byte)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Int16:
//                    {
//                        var resultStart = (short*)results.Address;
//                        var leftStart = (short*)lhs.Address;
//                        var rightScalar = *(short*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (short)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (short)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.UInt16:
//                    {
//                        var resultStart = (ushort*)results.Address;
//                        var leftStart = (ushort*)lhs.Address;
//                        var rightScalar = *(ushort*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (ushort)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (ushort)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Int32:
//                    {
//                        var resultStart = (int*)results.Address;
//                        var leftStart = (int*)lhs.Address;
//                        var rightScalar = *(int*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (int)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (int)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.UInt32:
//                    {
//                        var resultStart = (uint*)results.Address;
//                        var leftStart = (uint*)lhs.Address;
//                        var rightScalar = *(uint*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (uint)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (uint)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Int64:
//                    {
//                        var resultStart = (long*)results.Address;
//                        var leftStart = (long*)lhs.Address;
//                        var rightScalar = *(long*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (long)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (long)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.UInt64:
//                    {
//                        var resultStart = (ulong*)results.Address;
//                        var leftStart = (ulong*)lhs.Address;
//                        var rightScalar = *(ulong*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (ulong)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (ulong)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Char:
//                    {
//                        var resultStart = (char*)results.Address;
//                        var leftStart = (char*)lhs.Address;
//                        var rightScalar = *(char*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (char)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (char)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Double:
//                    {
//                        var resultStart = (double*)results.Address;
//                        var leftStart = (double*)lhs.Address;
//                        var rightScalar = *(double*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (double)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (double)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Single:
//                    {
//                        var resultStart = (float*)results.Address;
//                        var leftStart = (float*)lhs.Address;
//                        var rightScalar = *(float*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (float)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (float)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Decimal:
//                    {
//                        var resultStart = (decimal*)results.Address;
//                        var leftStart = (decimal*)lhs.Address;
//                        var rightScalar = *(decimal*)rhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (decimal)(*(leftStart + i) + rightScalar); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (decimal)(*(leftStart + i) + rightScalar);
//                            }
//                        }

//                        break;
//                    }

//                    default:
//                        throw new NotSupportedException();
//#endif
//                }

//                return results;
//            }

//            if (isLeftScalar)
//            {
//                //Left is a scalar
//                results = new NDArray(np._FindCommonArrayScalarType(rhs.GetTypeCode, lhs.GetTypeCode));
//                results.Storage.Allocate(retShape);

//                #region Math

//                switch (rhs.GetTypeCode)
//                {
//#if _REGEN
//                %foreach supported_numericals,supported_numericals_lowercase%
//                    case NPTypeCode.#1: {
//                        var resultStart = (#2*) results.Address;
//                        var rightStart = (#2*) rhs.Address;
//                        var leftScalar = *(#2*) lhs.Address;
//                        if (lhsCount > ParallelLimit) {
//                            Parallel.For(0, lhsCount, i => { *(resultStart + i) = (#2)(leftScalar + *(rightStart + i)); });
//                        } else {
//                            for (int i = 0; i < lhsCount; i++) {
//                                *(resultStart + i) = (#2)(leftScalar + *(rightStart + i));
//                            }
//                        }
//                        break;
//                    }
//                %

//                    default:
//                        throw new NotSupportedException();
//#else
//                    case NPTypeCode.Byte:
//                    {
//                        var resultStart = (byte*)results.Address;
//                        var rightStart = (byte*)rhs.Address;
//                        var leftScalar = *(byte*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (byte)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (byte)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Int16:
//                    {
//                        var resultStart = (short*)results.Address;
//                        var rightStart = (short*)rhs.Address;
//                        var leftScalar = *(short*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (short)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (short)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.UInt16:
//                    {
//                        var resultStart = (ushort*)results.Address;
//                        var rightStart = (ushort*)rhs.Address;
//                        var leftScalar = *(ushort*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (ushort)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (ushort)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Int32:
//                    {
//                        var resultStart = (int*)results.Address;
//                        var rightStart = (int*)rhs.Address;
//                        var leftScalar = *(int*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (int)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (int)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.UInt32:
//                    {
//                        var resultStart = (uint*)results.Address;
//                        var rightStart = (uint*)rhs.Address;
//                        var leftScalar = *(uint*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (uint)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (uint)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Int64:
//                    {
//                        var resultStart = (long*)results.Address;
//                        var rightStart = (long*)rhs.Address;
//                        var leftScalar = *(long*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (long)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (long)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.UInt64:
//                    {
//                        var resultStart = (ulong*)results.Address;
//                        var rightStart = (ulong*)rhs.Address;
//                        var leftScalar = *(ulong*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (ulong)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (ulong)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Char:
//                    {
//                        var resultStart = (char*)results.Address;
//                        var rightStart = (char*)rhs.Address;
//                        var leftScalar = *(char*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (char)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (char)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Double:
//                    {
//                        var resultStart = (double*)results.Address;
//                        var rightStart = (double*)rhs.Address;
//                        var leftScalar = *(double*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (double)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (double)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Single:
//                    {
//                        var resultStart = (float*)results.Address;
//                        var rightStart = (float*)rhs.Address;
//                        var leftScalar = *(float*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (float)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (float)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    case NPTypeCode.Decimal:
//                    {
//                        var resultStart = (decimal*)results.Address;
//                        var rightStart = (decimal*)rhs.Address;
//                        var leftScalar = *(decimal*)lhs.Address;
//                        if (size > ParallelLimit)
//                        {
//                            Parallel.For(0, size, i => { *(resultStart + i) = (decimal)(leftScalar + *(rightStart + i)); });
//                        }
//                        else
//                        {
//                            for (int i = 0; i < size; i++)
//                            {
//                                *(resultStart + i) = (decimal)(leftScalar + *(rightStart + i));
//                            }
//                        }

//                        break;
//                    }

//                    default:
//                        throw new NotSupportedException();
//#endif

//                    #endregion
//                }

//                return results;
//            }

//            throw new NotSupportedException();
        }

        //[MethodImpl((MethodImplOptions) 768)]
        //public static unsafe DArray<T> operator +(DArray<T> lhs, DArray<T> rhs) {
        //    int lhsCount = Math.Max(lhs.Count, rhs.Count);
        //    //this is a large array, use vectors.
        //    int numVectors = lhsCount / vectorSlots;
        //    int ceiling = numVectors * vectorSlots;

        //    DArray<T> results;
        //    var isLeftScalar = lhs.Shape.Size == 1;
        //    var isRightScalar = rhs.Shape.Size == 1;
        //    if (!isLeftScalar && !isRightScalar)
        //    {
        //        //None is a scalar is a scalar
        //        Debug.Assert(lhs.Shape == rhs.Shape);
        //        results = new DArray<T>(lhs._shape, false);
        //        Span<Vector<T>> resultsVecArray = CastVector(results);
        //        ReadOnlySpan<Vector<T>> rightVecArray = CastVector(rhs);
        //        ReadOnlySpan<Vector<T>> leftVecArray = CastVector(lhs);
        //        for (int i = 0; i < numVectors; i++)
        //        {
        //            resultsVecArray[i] = leftVecArray[i] + rightVecArray[i];
        //        }

        //        var resultAddr = results.Address;
        //        // Finish operation with any numbers leftover
        //        for (int i = ceiling; i < lhsCount; i++)
        //        {
        //            *(resultAddr + i) = (new Vector<T>(*(lhs.Address + i)) + new Vector<T>(*(rhs.Address + i)))[0];
        //        }
        //    }
        //    else if (isLeftScalar)
        //    {
        //        //Left is a scalar
        //        results = new DArray<T>(rhs._shape, false);
        //        Span<Vector<T>> resultsVecArray = CastVector(results);
        //        ReadOnlySpan<Vector<T>> rightVecArray = CastVector(rhs);
        //        var leftScalar = new Vector<T>(lhs.GetIndex(0));
        //        for (int i = 0; i < numVectors; i++)
        //        {
        //            resultsVecArray[i] = leftScalar + rightVecArray[i];
        //        }

        //        var resultAddr = results.Address;

        //        // Finish operation with any numbers leftover
        //        for (int i = ceiling; i < lhsCount; i++)
        //        {
        //            *(resultAddr + i) = (leftScalar + new Vector<T>(*(rhs.Address + i)))[0];
        //        }
        //    }
        //    else
        //    {
        //        //Right is a scalar
        //        results = new DArray<T>(lhs._shape, false);
        //        Span<Vector<T>> resultsVecArray = CastVector(results);
        //        ReadOnlySpan<Vector<T>> leftVecArray = CastVector(lhs);
        //        var rightScalar = new Vector<T>(rhs.GetIndex(0));
        //        for (int i = 0; i < numVectors; i++)
        //        {
        //            resultsVecArray[i] = leftVecArray[i] + rightScalar;
        //        }

        //        var resultAddr = results.Address;
        //        // Finish operation with any numbers leftover
        //        for (int i = ceiling; i < lhsCount; i++)
        //        {
        //            *(resultAddr + i) = (new Vector<T>(*(lhs.Address + i)) + rightScalar)[0];
        //        }
        //    }

        //    return results;
        //}
        //[MethodImpl((MethodImplOptions)768)]
        //public static NDArray Add(NDArray lhs)
        //{
        //    return lhs.Clone();
        //}

        //[MethodImpl((MethodImplOptions)768)]
        //public static NDArray Add<TRight>(NDArray lhs, T rhs)
        //{
        //    return lhs + Scalar(rhs);
        //}

        //[MethodImpl((MethodImplOptions)768)]
        //public static NDArray Add(T lhs, NDArray rhs)
        //{
        //    return NDArray.Scalar(lhs) + rhs;
        //}
    }
}
