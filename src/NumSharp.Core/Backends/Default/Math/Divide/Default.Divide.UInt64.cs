//Generated by Regex Templating Engine at 08/08/2019 23:47:45 UTC
//template source: C:\Users\Eli-PC\Desktop\SciSharp\NumSharp\src\NumSharp.Core\Backends\Default\Math\Templates\Default.Op.General.template.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using NumSharp.Backends.Unmanaged;
using NumSharp.Utilities;
using NumSharp.Utilities.Maths;

namespace NumSharp.Backends
{
    public partial class DefaultEngine
    {
        [MethodImpl((MethodImplOptions)768)]
        [SuppressMessage("ReSharper", "JoinDeclarationAndInitializer")]
        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        public unsafe NDArray DivideUInt64(in NDArray lhs, in NDArray rhs)
        {
            //lhs is NDArray of ulong
            switch (rhs.GetTypeCode)
            {
#if _REGEN
                %op = "Divide"
                %op_bool = "*"
	            %foreach supported_dtypes, supported_dtypes_lowercase%
                case NPTypeCode.#1:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.#(op)(*((ulong*)lhs.Address), *((#2*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (#2*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        %foreach supported_dtypes,supported_dtypes_lowercase%
                        |#normalcast = ("("+str("#102")+")")
                        //new
                        |#caster = ( "#102"=="bool" | ("Converts.To" + str("#101")) | ("ulong"=="bool"|("#2"=="bool"|("Converts.To" + str("#101"))|normalcast)| normalcast) )
	                    case NPTypeCode.#101:
	                    {
		                    var ret_address = (#102*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = #(caster)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = #(caster)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = #(caster)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = #(caster)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        %
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                %
                default:
		            throw new NotSupportedException();
#else

                case NPTypeCode.Boolean:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((bool*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (bool*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Byte:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((byte*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (byte*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Int16:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((short*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (short*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.UInt16:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((ushort*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (ushort*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Int32:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((int*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (int*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.UInt32:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((uint*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (uint*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Int64:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((long*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (long*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.UInt64:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((ulong*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (ulong*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Char:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((char*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (char*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Double:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((double*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (double*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Single:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((float*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (float*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Decimal:
                {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Divide(*((ulong*)lhs.Address), *((decimal*)rhs.Address)), ret_type));

                    (Shape BroadcastedLeftShape, Shape BroadcastedRightShape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (ulong*)lhs.Address;
                    var rhs_address = (decimal*)rhs.Address;
                    var retShape = BroadcastedLeftShape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !BroadcastedLeftShape.IsBroadcasted && !BroadcastedLeftShape.IsSliced;
                    var rightLinear = !BroadcastedRightShape.IsBroadcasted && !BroadcastedRightShape.IsSliced;
                    switch (ret_type)
                    {
                        //new
	                    case NPTypeCode.Boolean:
	                    {
		                    var ret_address = (bool*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = Converts.ToBoolean(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = Converts.ToBoolean(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Byte:
	                    {
		                    var ret_address = (byte*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (byte)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (byte)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int16:
	                    {
		                    var ret_address = (short*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (short)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (short)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt16:
	                    {
		                    var ret_address = (ushort*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ushort)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ushort)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int32:
	                    {
		                    var ret_address = (int*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (int)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (int)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt32:
	                    {
		                    var ret_address = (uint*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (uint)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (uint)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Int64:
	                    {
		                    var ret_address = (long*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (long)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (long)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.UInt64:
	                    {
		                    var ret_address = (ulong*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (ulong)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (ulong)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Char:
	                    {
		                    var ret_address = (char*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (char)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (char)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Double:
	                    {
		                    var ret_address = (double*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (double)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (double)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Single:
	                    {
		                    var ret_address = (float*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (float)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (float)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        //new
	                    case NPTypeCode.Decimal:
	                    {
		                    var ret_address = (decimal*)ret.Address;
                            if (leftLinear && rightLinear) {
                                var len = ret.size;
                                Debug.Assert(BroadcastedLeftShape.size == len && BroadcastedRightShape.size == len);
                                Parallel.For(0, len, i => *(ret_address + i) = (decimal)(Operator.Divide((*(lhs_address + i)), (*(rhs_address + i)))));
                            } else if (leftLinear && !rightLinear) {
                                int leftOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + leftOffset++)), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            } else if (!leftLinear && rightLinear) {
                                int rightOffset = 0;
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + rightOffset++))));
                                } while (incr.Next() != null);
                            } else {
                                int retOffset = 0;
                                var incr = new NDCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    *(ret_address + retOffset++) = (decimal)(Operator.Divide((*(lhs_address + BroadcastedLeftShape.GetOffset(current))), (*(rhs_address + BroadcastedRightShape.GetOffset(current)))));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                default:
		            throw new NotSupportedException();
#endif
            }
        }
    }
}
