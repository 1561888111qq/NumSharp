/*
This file was generated by template ../NDArray.Elementwise.tt
In case you want to do some changes do the following 

1 ) adapt the tt file
2 ) execute powershell file "GenerateCode.ps1" on root level

*/
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Numerics;
using NumSharp.Shared;

namespace NumSharp.Backends
{
    public abstract partial class DefaultEngine
    {
       public virtual NDArray Add(NDArray x, NDArray y)
       {
            /// following code is for determine if scalar or not
            /// also for determine result
            int scalarNo = !(x.ndim == 0 || y.ndim == 0) ? 0 : -1;
            
            if( scalarNo == 0 )
            {
                if (!Enumerable.SequenceEqual(x.shape,y.shape))
                {
                    throw new IncorrectShapeException();
                }
            }
            else
            {
                if (x.ndim == 0)
                    scalarNo = 1;
                else 
                    scalarNo = 2;
            }
                    
            NDArray result = null;

            switch (scalarNo)
            {
                case 1 : 
                {
                    result = new NDArray(y.dtype,y.shape);
                    break;
                }
                case 2 : 
                {
                    result = new NDArray(x.dtype,x.shape);
                    break;
                }
                default :
                {
                    result = new NDArray(x.dtype,x.shape);
                    break;
                } 
            } 

            Array np1SysArr = x.Storage.GetData();
            Array np2SysArr = y.Storage.GetData();
            Array np3SysArr = result.Storage.GetData();

            switch (np3SysArr)
            {
            
				case System.Int32[] resArr : 
				{
				    var np1Array = np1SysArr as int[];
				    var np2Array = np2SysArr as int[];
				    np1Array = (np1Array == null) ? x.Storage.CloneData<int>() : np1Array;
				    np2Array = (np2Array == null) ? y.Storage.CloneData<int>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        var scalar = x.Storage.CloneData<int>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar + np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        var scalar = y.Storage.CloneData<int>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + scalar;
				    }
				    break;
				}

				case System.Int64[] resArr : 
				{
				    var np1Array = np1SysArr as long[];
				    var np2Array = np2SysArr as long[];
				    np1Array = (np1Array == null) ? x.Storage.CloneData<long>() : np1Array;
				    np2Array = (np2Array == null) ? y.Storage.CloneData<long>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        var scalar = x.Storage.CloneData<long>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar + np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        var scalar = y.Storage.CloneData<long>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + scalar;
				    }
				    break;
				}

				case System.Single[] resArr : 
				{
				    var np1Array = np1SysArr as float[];
				    var np2Array = np2SysArr as float[];
				    np1Array = (np1Array == null) ? x.Storage.CloneData<float>() : np1Array;
				    np2Array = (np2Array == null) ? y.Storage.CloneData<float>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        var scalar = x.Storage.CloneData<float>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar + np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        var scalar = y.Storage.CloneData<float>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + scalar;
				    }
				    break;
				}

				case System.Double[] resArr : 
				{
				    var np1Array = np1SysArr as double[];
				    var np2Array = np2SysArr as double[];
				    np1Array = (np1Array == null) ? x.Storage.CloneData<double>() : np1Array;
				    np2Array = (np2Array == null) ? y.Storage.CloneData<double>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        var scalar = x.Storage.CloneData<double>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar + np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        var scalar = y.Storage.CloneData<double>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + scalar;
				    }
				    break;
				}

				case System.Numerics.Complex[] resArr : 
				{
				    Complex[] np1Array = np1SysArr as Complex[];
				    Complex[] np2Array = np2SysArr as Complex[];
				    np1Array = (np1Array == null) ? x.Storage.CloneData<Complex>() : np1Array;
				    np2Array = (np2Array == null) ? y.Storage.CloneData<Complex>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        Complex scalar = x.Storage.CloneData<Complex>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar + np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        Complex scalar = y.Storage.CloneData<Complex>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + scalar;
				    }
				    break;
				}

				/*case System.Numerics.Quaternion[] resArr : 
				{
				    System.Numerics.Quaternion[] np1Array = np1SysArr as System.Numerics.Quaternion[];
				    System.Numerics.Quaternion[] np2Array = np2SysArr as System.Numerics.Quaternion[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Numerics.Quaternion>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Numerics.Quaternion>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Numerics.Quaternion scalar = np1.Storage.CloneData<System.Numerics.Quaternion>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar + np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Numerics.Quaternion scalar = np2.Storage.CloneData<System.Numerics.Quaternion>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] + scalar;
				    }
				    break;
				}*/
                default : 
                {
                    throw new IncorrectTypeException();
                }
            }

            return result;
        }
        
    }

}

