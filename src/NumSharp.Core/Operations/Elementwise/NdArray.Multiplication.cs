/*
This file was generated by template ../NDArray.Elementwise.tt
In case you want to do some changes do the following 

1 ) adapt the tt file
2 ) execute powershell file "GenerateCode.ps1" on root level

*/
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Numerics;
using NumSharp.Core.Shared;
 
namespace NumSharp.Core
{
    public partial class NDArray
    {
       public static NDArray operator *(NDArray np1, NDArray np2)
       {
            /// following code is for determine if scalar or not
            /// also for determine result
            int scalarNo = !(np1.ndim == 0 || np2.ndim == 0) ? 0 : -1;
            
            if( scalarNo == 0 )
            {
                if (!Enumerable.SequenceEqual(np1.shape,np2.shape))
                {
                    throw new IncorrectShapeException();
                }
            }
            else
            {
                if (np1.ndim == 0)
                    scalarNo = 1;
                else 
                    scalarNo = 2;
            }
                    
            NDArray result = null;

            switch (scalarNo)
            {
                case 1 : 
                {
                    result = new NDArray(np2.dtype,np2.shape);
                    break;
                }
                case 2 : 
                {
                    result = new NDArray(np1.dtype,np1.shape);
                    break;
                }
                default :
                {
                    result = new NDArray(np1.dtype,np1.shape);
                    break;
                } 
            } 

            Array np1SysArr = np1.Storage.GetData();
            Array np2SysArr = np2.Storage.GetData();
            Array np3SysArr = result.Storage.GetData();

            switch (np3SysArr)
            {
            
				case System.Int32[] resArr : 
				{
				    System.Int32[] np1Array = np1SysArr as System.Int32[];
				    System.Int32[] np2Array = np2SysArr as System.Int32[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Int32>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Int32>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Int32 scalar = np1.Storage.CloneData<System.Int32>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar * np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Int32 scalar = np2.Storage.CloneData<System.Int32>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * scalar;
				    }
				    break;
				}

				case System.Int64[] resArr : 
				{
				    System.Int64[] np1Array = np1SysArr as System.Int64[];
				    System.Int64[] np2Array = np2SysArr as System.Int64[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Int64>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Int64>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Int64 scalar = np1.Storage.CloneData<System.Int64>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar * np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Int64 scalar = np2.Storage.CloneData<System.Int64>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * scalar;
				    }
				    break;
				}

				case System.Single[] resArr : 
				{
				    System.Single[] np1Array = np1SysArr as System.Single[];
				    System.Single[] np2Array = np2SysArr as System.Single[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Single>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Single>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Single scalar = np1.Storage.CloneData<System.Single>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar * np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Single scalar = np2.Storage.CloneData<System.Single>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * scalar;
				    }
				    break;
				}

				case System.Double[] resArr : 
				{
				    System.Double[] np1Array = np1SysArr as System.Double[];
				    System.Double[] np2Array = np2SysArr as System.Double[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Double>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Double>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Double scalar = np1.Storage.CloneData<System.Double>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar * np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Double scalar = np2.Storage.CloneData<System.Double>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * scalar;
				    }
				    break;
				}

				case System.Numerics.Complex[] resArr : 
				{
				    System.Numerics.Complex[] np1Array = np1SysArr as System.Numerics.Complex[];
				    System.Numerics.Complex[] np2Array = np2SysArr as System.Numerics.Complex[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Numerics.Complex>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Numerics.Complex>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Numerics.Complex scalar = np1.Storage.CloneData<System.Numerics.Complex>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar * np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Numerics.Complex scalar = np2.Storage.CloneData<System.Numerics.Complex>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * scalar;
				    }
				    break;
				}

				case System.Numerics.Quaternion[] resArr : 
				{
				    System.Numerics.Quaternion[] np1Array = np1SysArr as System.Numerics.Quaternion[];
				    System.Numerics.Quaternion[] np2Array = np2SysArr as System.Numerics.Quaternion[];
				    np1Array = (np1Array == null) ? np1.Storage.CloneData<System.Numerics.Quaternion>() : np1Array;
				    np2Array = (np2Array == null) ? np2.Storage.CloneData<System.Numerics.Quaternion>() : np2Array;

				    if (scalarNo == 0 )
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * np2Array[idx];
				    else if (scalarNo == 1 )
				    {
				        System.Numerics.Quaternion scalar = np1.Storage.CloneData<System.Numerics.Quaternion>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = scalar * np2Array[idx];
				    }
				    else if (scalarNo == 2 )
				    {
				        System.Numerics.Quaternion scalar = np2.Storage.CloneData<System.Numerics.Quaternion>()[0];
				        for( int idx = 0; idx < np3SysArr.Length;idx++)
				            resArr[idx] = np1Array[idx] * scalar;
				    }
				    break;
				}
                default : 
                {
                    throw new IncorrectTypeException();
                }
            }

            return result;
        }
        
    }

}

